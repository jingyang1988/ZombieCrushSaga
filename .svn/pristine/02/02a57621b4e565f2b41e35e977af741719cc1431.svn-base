/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package zombiecrush.ui;

import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import javax.swing.JPanel;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import mini_game.MiniGame;
import mini_game.Sprite;
import mini_game.SpriteType;
import zombiecrush.data.ZombieCrushDataModel;
import zombiecrush.ZombieCrush.ZombieCrushPropertyType;
import static zombiecrush.ZombieCrushConstants.*;
import zombiecrush.data.ZombieCrushRecord;
/**
 *
 * @author Jing
 */
public class ZombieCrushPanel extends JPanel{
    // THIS IS ACTUALLY OUR Mahjong Solitaire APP, WE NEED THIS
    // BECAUSE IT HAS THE GUI STUFF THAT WE NEED TO RENDER
    private MiniGame game;
    private ZombieCrushMiniGame xgame;
    
    // AND HERE IS ALL THE GAME DATA THAT WE NEED TO RENDER
    private ZombieCrushDataModel data;
    
    // WE'LL USE THIS TO FORMAT SOME TEXT FOR DISPLAY PURPOSES
    private NumberFormat numberFormatter;
   // WE'LL USE THIS AS THE BASE IMAGE FOR RENDERING UNSELECTED TILES
    private BufferedImage blankTileImage;
    
    // WE'LL USE THIS AS THE BASE IMAGE FOR RENDERING SELECTED TILES
    private BufferedImage blankTileSelectedImage;
    private ZombieCrushRecord record;
    public ZombieCrushPanel(ZombieCrushMiniGame initGame, ZombieCrushDataModel initData)
    {
        game = initGame;
        data = initData;
        numberFormatter = NumberFormat.getNumberInstance();
        numberFormatter.setMinimumFractionDigits(3);
        numberFormatter.setMaximumFractionDigits(3);
    }
        
    // MUTATOR METHODS
        // -setBlankTileImage
        // -setBlankTileSelectedImage
    
    /**
     * This mutator method sets the base image to use for rendering tiles.
     * 
     * @param initBlankTileImage The image to use as the base for rendering tiles.
     */
    public void setBlankTileImage(BufferedImage initBlankTileImage)
    {
        blankTileImage = initBlankTileImage;
    }
    
    /**
     * This mutator method sets the base image to use for rendering selected tiles.
     * 
     * @param initBlankTileSelectedImage The image to use as the base for rendering
     * selected tiles.
     */
    public void setBlankTileSelectedImage(BufferedImage initBlankTileSelectedImage)
    {
        blankTileSelectedImage = initBlankTileSelectedImage;
    }

    
    
    
      @Override
    public void paintComponent(Graphics g)
    {
        try
        {
            // MAKE SURE WE HAVE EXCLUSIVE ACCESS TO THE GAME DATA
            game.beginUsingData();
        
            // CLEAR THE PANEL
            super.paintComponent(g);
        
            // RENDER THE BACKGROUND, WHICHEVER SCREEN WE'RE ON
            renderBackground(g);
            // AND THE BUTTONS AND DECOR
            renderGUIControls(g);
            renderStats(g);
     
        
        }
        finally
        {
            // RELEASE THE LOCK
            game.endUsingData();    
        }
    }
    public void renderBackground(Graphics g)
    {
        String s=((ZombieCrushMiniGame)game).getCurrentScreenState();
        //if(s.equals("SAGA_SCREEN_STATE")){
        //Sprite bg = game.getGUIDecor().get("SAGASCREEN_TYPE");
            //renderSprite(g, bg);
        
    //}
        // THERE IS ONLY ONE CURRENTLY SET
        //if(xgame.getCurrentScreenState().equals("SAGA_SCREEN_STATE")){
            //Sprite bg = game.getGUIDecor().get("SAGASCREEN_TYPE");
            //renderSprite(g, bg);     
        //}
       
            Sprite bg = game.getGUIDecor().get("BACKGROUND_TYPE");
            renderSprite(g, bg);
 
         
    }
        public void renderGUIControls(Graphics g)
    {
        // GET EACH DECOR IMAGE ONE AT A TIME
        Collection<Sprite> decorSprites = game.getGUIDecor().values();
        for (Sprite s : decorSprites)
        {
            renderSprite(g, s);
        }
        
        // AND NOW RENDER THE BUTTONS
        Collection<Sprite> buttonSprites = game.getGUIButtons().values();
        for (Sprite s : buttonSprites)
        {
            renderSprite(g, s);
        }
    }
    /**
     * Renders the game dialog boxes.
     * 
     * @param g This panel's graphics context.
     */
    public void renderDialogs(Graphics g)
    {
        // GET EACH DECOR IMAGE ONE AT A TIME
        Collection<Sprite> dialogSprites = game.getGUIDialogs().values();
        for (Sprite s : dialogSprites)
        {
            // RENDER THE DIALOG, NOTE IT WILL ONLY DO IT IF IT'S VISIBLE
            renderSprite(g, s);
        }
    }
     public void renderStats(Graphics g){
         String s=((ZombieCrushMiniGame)game).getCurrentScreenState();
         if(s.equals(LEVEL_SCORE_SCREEN_STATE)){
      g.setColor(DEBUG_TEXT_COLOR);
             g.setFont(TEXT_DISPLAY_FONT);
            String level = "LEVEL1";
            int x = 1;
            int y = 100;
            g.drawString(level, x, y);
            g.setColor(DEBUG_TEXT_COLOR);
            g.setFont(TEXT_DISPLAY_FONT);
            
            String score="SCORE:";
             int a = 1;
             int b = 200;
             g.drawString(score, a, b);
            
            g.setColor(DEBUG_TEXT_COLOR);
            g.setFont(TEXT_DISPLAY_FONT);
            String star="STARS:";
             int c = 1;
             int d = 300;
             g.drawString(star, c, d);
             
             g.setColor(DEBUG_TEXT_COLOR);
            g.setFont(TEXT_DISPLAY_FONT);
            String ins="INSTRUCTIONS:"+"\n";
            ins+="GET 10000 POINTS!";
             int e = 400;
             int f = 450;
             g.drawString(ins, e, f);
             
         }
     }
         
    /**
     * Renders all the game tiles, doing so carefully such
     * that they are rendered in the proper order.
     * 
     * @param g the Graphics context of this panel.
     */
    public void renderTiles(Graphics g)
    {
        // DRAW THE TOP TILES ON THE STACK
        if (!data.won())
        {
            // WE DRAW ONLY THE TOP 4 (OR 2 IF THERE ARE ONLY 2). THE REASON
            // WE DRAW 4 IS THAT WHILE WE MOVE MATCHES TO THE STACK WE WANT
            // TO SEE THE STACK
            ArrayList<ZombieCrushTile> stackTiles = data.getStackTiles();
            if (stackTiles.size() > 3)
            {
                renderTile(g, stackTiles.get(stackTiles.size()-3));
                renderTile(g, stackTiles.get(stackTiles.size()-4));
            }
            if (stackTiles.size() > 1)
            {
                renderTile(g, stackTiles.get(stackTiles.size()-1));
                renderTile(g, stackTiles.get(stackTiles.size()-2));
            }
        }
        
        // THEN DRAW THE GRID TILES BOTTOM TO TOP USING
        // THE TILE'S Z TO STAGGER THEM AND GIVE THE ILLUSION
        // OF DEPTH
        ArrayList<ZombieCrushTile>[][] tileGrid = data.getTileGrid();
        boolean noneOnLevel = false;
        int zIndex = 0;
        while (!noneOnLevel)
        {
            int levelCounter = 0;
            for (int i = 0; i < data.getGridColumns(); i++)
            {
                for (int j = 0; j < data.getGridRows(); j++)
                {
                    if (tileGrid[i][j].size() > zIndex)
                    {
                        ZombieCrushTile tile = tileGrid[i][j].get(zIndex);
                        renderTile(g, tile);
                        levelCounter++;
                    }
                }
            }
            if (levelCounter == 0)
                noneOnLevel = true;
            zIndex++;
        }
        
        // THEN DRAW ALL THE MOVING TILES
        Iterator<ZombieCrushTile> movingTiles = data.getMovingTiles();
        while (movingTiles.hasNext())
        {
            ZombieCrushTile tile = movingTiles.next();
            renderTile(g, tile);
        }
    }

    /**
     * Helper method for rendering the tiles that are currently moving.
     * 
     * @param g Rendering context for this panel.
     * 
     * @param tileToRender Tile to render to this panel.
     */
    public void renderTile(Graphics g, ZombieCrushTile tileToRender)
    {
        // ONLY RENDER VISIBLE TILES
        if (!tileToRender.getState().equals(INVISIBLE_STATE))
        {
            // FIRST DRAW THE BLANK TILE IMAGE
          
 if (tileToRender.getState().equals(VISIBLE_STATE)){
                g.drawImage(blankTileImage, (int)tileToRender.getX(), (int)tileToRender.getY(), null);
 }
            
            // THEN THE TILE IMAGE
            SpriteType bgST = tileToRender.getSpriteType();
            Image img = bgST.getStateImage(tileToRender.getState());
            g.drawImage(img, (int)tileToRender.getX()+TILE_IMAGE_OFFSET, (int)tileToRender.getY()+TILE_IMAGE_OFFSET, bgST.getWidth(), bgST.getHeight(), null); 
            
         
        }        
    }
    


    /**
     * This method renders grid lines in the game tile grid to help
     * during debugging.
     * 
     * @param g Graphics context for this panel.
     */
    public void renderGrid(Graphics g)
    {
        // ONLY RENDER THE GRID IF WE'RE DEBUGGING
        if (data.isDebugTextRenderingActive())
        {
            for (int i = 0; i < data.getGridColumns(); i++)
            {
                for (int j = 0; j < data.getGridRows(); j++)
                {
                    int x = data.calculateTileXInGrid(i, 0);
                    int y = data.calculateTileYInGrid(j, 0);
                    g.drawRect(x, y, TILE_IMAGE_WIDTH, TILE_IMAGE_HEIGHT);
                }
            }
        }
    }
     
    public void renderSprite(Graphics g, Sprite s)
    {
        // ONLY RENDER THE VISIBLE ONES
        if (!s.getState().equals("INVISIBLE_STATE"))
        {
            SpriteType bgST = s.getSpriteType();
            Image img = bgST.getStateImage(s.getState());
            g.drawImage(img, (int)s.getX(), (int)s.getY(), bgST.getWidth(), bgST.getHeight(), null); 
        }
    }
}
