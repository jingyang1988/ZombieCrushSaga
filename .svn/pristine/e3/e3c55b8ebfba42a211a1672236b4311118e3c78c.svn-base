/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package zombiecrush.data;
import zombiecrush.ui.ZombieCrushTile;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.Vector;
import zombiecrush.ZombieCrush.ZombieCrushPropertyType;
import mini_game.MiniGame;
import mini_game.MiniGameDataModel;
import mini_game.Sprite;
import mini_game.SpriteType;
import properties_manager.PropertiesManager;
import static zombiecrush.ZombieCrushConstants.*;
import zombiecrush.ui.ZombieCrushMiniGame;
import zombiecrush.ui.ZombieCrushPanel;

/**
 *
 * @author Jing
 */
public class ZombieCrushDataModel extends MiniGameDataModel{
    // THIS CLASS HAS A REFERERENCE TO THE MINI GAME SO THAT IT
    // CAN NOTIFY IT TO UPDATE THE DISPLAY WHEN THE DATA MODEL CHANGES
    private MiniGame miniGame;
    
    // THE LEVEL GRID REFERS TO THE LAYOUT FOR A GIVEN LEVEL, MEANING
    // HOW MANY TILES FIT INTO EACH CELL WHEN FIRST STARTING A LEVEL
    private int[][] levelGrid;
    
    // LEVEL GRID DIMENSIONS
    private int gridColumns;
    private int gridRows;
    
    // THIS STORES THE TILES ON THE GRID DURING THE GAME
    private ArrayList<ZombieCrushTile>[][] tileGrid;
    
    // THESE ARE THE TILES THE PLAYER HAS MATCHED
    private ArrayList<ZombieCrushTile> stackTiles;
    
    // THESE ARE THE TILES THAT ARE MOVING AROUND, AND SO WE HAVE TO UPDATE
    private ArrayList<ZombieCrushTile> movingTiles;
    
    // THIS IS A SELECTED TILE, MEANING THE FIRST OF A PAIR THE PLAYER
    // IS TRYING TO MATCH. THERE CAN ONLY BE ONE OF THESE AT ANY TIME
    private ZombieCrushTile selectedTile;
    
    // THE INITIAL LOCATION OF TILES BEFORE BEING PLACED IN THE GRID
    private int unassignedTilesX;
    private int unassignedTilesY;
    
    // THESE ARE USED FOR TIMING THE GAME
    private GregorianCalendar startTime;
    private GregorianCalendar endTime;
    
    // THE REFERENCE TO THE FILE BEING PLAYED
    private String currentLevel;
    private Vector<Sprite> saga;
     /**
     * Accessor method for getting the number of tile columns in the game grid.
     * 
     * @return The number of columns (left to right) in the grid for the level
     * currently loaded.
     */
    public int getGridColumns() 
    { 
        return gridColumns; 
    }
    
    /**
     * Accessor method for getting the number of tile rows in the game grid.
     * 
     * @return The number of rows (top to bottom) in the grid for the level
     * currently loaded.
     */
    public int getGridRows() 
    { 
        return gridRows; 
    }
    /**
     * Constructor for initializing this data model, it will create
     * the data structures for storing tiles, but not the tile grid
     * itself, that is dependent of file loading, and so should be
     * subsequently initialized.
     * 
     * @param initMiniGame The Mahjong game UI.
     */
    public ZombieCrushDataModel(MiniGame initMiniGame)
    {
        // KEEP THE GAME FOR LATER
        miniGame = initMiniGame;
        
        // INIT THESE FOR HOLDING MATCHED AND MOVING TILES
        stackTiles = new ArrayList();
        movingTiles = new ArrayList();
    }
    /**
     * This method loads the tiles, creating an individual sprite for each. Note
     * that tiles may be of various types, which is important during the tile
     * matching tests.
     */
    public void initTiles()
    {
        PropertiesManager props = PropertiesManager.getPropertiesManager();        
        String imgPath = props.getProperty(ZombieCrushPropertyType.IMG_PATH);
        int spriteTypeID = 0;
        SpriteType sT;
        
        // WE'LL RENDER ALL THE TILES ON TOP OF THE BLANK TILE
        String blankTileFileName = props.getProperty(ZombieCrushPropertyType.BLANK_TILE_IMAGE_NAME);
        BufferedImage blankTileImage = miniGame.loadImageWithColorKey(imgPath + blankTileFileName, COLOR_KEY);
        ((ZombieCrushPanel)(miniGame.getCanvas())).setBlankTileImage(blankTileImage);
        
        
        
        // FIRST THE BASIC TILES, OF WHICH THERE IS ONLY ONE OF EACH
        // THIS IS ANALOGOUS TO THE SEASON TILES IN FLAVORLESS MAHJONG
        ArrayList<String> basicTiles = props.getPropertyOptionsList(ZombieCrushPropertyType.BASIC_TILES);
        for (int i = 0; i < basicTiles.size(); i++)
        {
            String imgFile = imgPath + basicTiles.get(i);            
            sT = initTileSpriteType(imgFile, TILE_SPRITE_TYPE_PREFIX + spriteTypeID);
            initTile(sT, BASIC_TYPE);
            spriteTypeID++;
        }
        
        // THEN THE SPECIAL TILES, WHICH ALSO ONLY HAVE ONE OF EACH
        // THIS IS ANALOGOUS TO THE FLOWER TILES IN FLAVORLESS MAHJONG
        ArrayList<String> specialTiles = props.getPropertyOptionsList(ZombieCrushPropertyType.SPECIAL_TILES);
        for (int i = 0; i < specialTiles.size(); i++)
        {
            String imgFile = imgPath + specialTiles.get(i);            
            sT = initTileSpriteType(imgFile, TILE_SPRITE_TYPE_PREFIX + spriteTypeID);
            initTile(sT, SPECIAL_TYPE);
            spriteTypeID++;
        }
        
      
    }
/**
     * Helper method for loading the tiles, it constructs the prescribed
     * tile type using the provided sprite type.
     * 
     * @param sT The sprite type to use to represent this tile during rendering.
     * 
     * @param tileType The type of tile. Note that there are 3 broad categories.
     */
    private void initTile(SpriteType sT, String tileType)
    {
        // CONSTRUCT THE TILE
        ZombieCrushTile newTile = new ZombieCrushTile(sT, unassignedTilesX, unassignedTilesY, 0, 0, INVISIBLE_STATE, tileType);
        
        // AND ADD IT TO THE STACK
        stackTiles.add(newTile);        
    }
 
    /**
     * Called after a level has been selected, it initializes the grid
     * so that it is the proper dimensions.
     * 
     * @param initGrid The grid distribution of tiles, where each cell 
     * specifies the number of tiles to be stacked in that cell.
     * 
     * @param initGridColumns The columns in the grid for the level selected.
     * 
     * @param initGridRows The rows in the grid for the level selected.
     */
    public void initLevelGrid(int[][] initGrid, int initGridColumns, int initGridRows)
    {
        // KEEP ALL THE GRID INFO
        levelGrid = initGrid;
        gridColumns = initGridColumns;
        gridRows = initGridRows;

        // AND BUILD THE TILE GRID FOR STORING THE TILES
        // SINCE WE NOW KNOW ITS DIMENSIONS
        tileGrid = new ArrayList[gridColumns][gridRows];
        for (int i = 0; i < gridColumns; i++)
        {
            for (int j = 0; j < gridRows; j++)
            {
                // EACH CELL HAS A STACK OF TILES, WE'LL USE
                // AN ARRAY LIST FOR THE STACK
                tileGrid[i][j] = new ArrayList();
            }
        }
        // MAKE ALL THE TILES VISIBLE
        enableTiles(true);
    }
    
    /**
     * This helper method initializes a sprite type for a tile or set of
     * similar tiles to be created.
     */
    private SpriteType initTileSpriteType(String imgFile, String spriteTypeID)
    {
        // WE'LL MAKE A NEW SPRITE TYPE FOR EACH GROUP OF SIMILAR LOOKING TILES
        SpriteType sT = new SpriteType(spriteTypeID);
        addSpriteType(sT);
        
        // LOAD THE ART
        BufferedImage img = miniGame.loadImageWithColorKey(imgFile, COLOR_KEY);
        Image tempImage = img.getScaledInstance(TILE_IMAGE_WIDTH, TILE_IMAGE_HEIGHT, BufferedImage.SCALE_SMOOTH);
        img = new BufferedImage(TILE_IMAGE_WIDTH, TILE_IMAGE_HEIGHT, BufferedImage.TYPE_INT_ARGB);
        img.getGraphics().drawImage(tempImage, 0, 0, null);
        
        // WE'LL USE THE SAME IMAGE FOR ALL STATES
        sT.addState(INVISIBLE_STATE, img);
        sT.addState(VISIBLE_STATE, img);
        sT.addState(SELECTED_STATE, img);
        sT.addState(INCORRECTLY_SELECTED_STATE, img);
        return sT;
    }
        
    // ACCESSOR METHODS

    /**
     * Accessor method for getting the level currently being played.
     * 
     * @return The level name used currently for the game screen.
     */
    public String getCurrentLevel() 
    { 
        return currentLevel; 
    }
/**
     * Accessor method for getting the tile grid, which has all the
     * tiles the user may select from.
     * 
     * @return The main 2D grid of tiles the user selects tiles from.
     */
    public ArrayList<ZombieCrushTile>[][] getTileGrid() 
    { 
        return tileGrid; 
    }
    
    /**
     * Accessor method for getting the stack tiles.
     * 
     * @return The stack tiles, which are the tiles the matched tiles
     * are placed in.
     */
    public ArrayList<ZombieCrushTile> getStackTiles()
    {
        return stackTiles;
    }

    /**
     * Accessor method for getting the moving tiles.
     * 
     * @return The moving tiles, which are the tiles currently being
     * animated as they move around the game. 
     */
    public Iterator<ZombieCrushTile> getMovingTiles()
    {
        return movingTiles.iterator();
    }
    
    /**
     * Mutator method for setting the currently loaded level.
     * 
     * @param initCurrentLevel The level name currently being used
     * to play the game.
     */
    public void setCurrentLevel(String initCurrentLevel)
    {
        currentLevel = initCurrentLevel;
    }

    /**
     * Used to calculate the x-axis pixel location in the game grid for a tile
     * placed at column with stack position z.
     * 
     * @param column The column in the grid the tile is located.
     * 
     * @param z The level of the tile in the stack at the given grid location.
     * 
     * @return The x-axis pixel location of the tile 
     */
    public int calculateTileXInGrid(int column, int z)
    {
        int cellWidth = TILE_IMAGE_WIDTH;
        float leftEdge = miniGame.getBoundaryLeft();
        return (int)(leftEdge + (cellWidth * column) - (Z_TILE_OFFSET * z));
    }
    
    /**
     * Used to calculate the y-axis pixel location in the game grid for a tile
     * placed at row with stack position z.
     * 
     * @param row The row in the grid the tile is located.
     * 
     * @param z The level of the tile in the stack at the given grid location.
     * 
     * @return The y-axis pixel location of the tile 
     */
    public int calculateTileYInGrid(int row, int z)
    {
        int cellHeight = TILE_IMAGE_HEIGHT;
        float topEdge = miniGame.getBoundaryTop();
        return (int)(topEdge + (cellHeight * row) - (Z_TILE_OFFSET * z));
    }

    /**
     * Used to calculate the grid column for the x-axis pixel location.
     * 
     * @param x The x-axis pixel location for the request.
     * 
     * @return The column that corresponds to the x-axis location x.
     */
    public int calculateGridCellColumn(int x)
    {
        float leftEdge = miniGame.getBoundaryLeft();
        x = (int)(x - leftEdge);
        return x / TILE_IMAGE_WIDTH;
    }

    /**
     * Used to calculate the grid row for the y-axis pixel location.
     * 
     * @param y The y-axis pixel location for the request.
     * 
     * @return The row that corresponds to the y-axis location y.
     */
    public int calculateGridCellRow(int y)
    {
        float topEdge = miniGame.getBoundaryTop();
        y = (int)(y - topEdge);
        return y / TILE_IMAGE_HEIGHT;
    }

    // GAME DATA SERVICE METHODS
        // -enableTiles
        // -findMove
        // -moveAllTilesToStack
        // -moveTiles
        // -playWinAnimation
        // -processMove
        // -selectTile
        // -undoLastMove

    /**
     * This method can be used to make all of the tiles either visible (true)
     * or invisible (false). This should be used when switching between the
     * splash and game screens.
     * 
     * @param enable Specifies whether the tiles should be made visible or not.
     */
    public void enableTiles(boolean enable)
    {
        // PUT ALL THE TILES IN ONE PLACE WHERE WE CAN PROCESS THEM TOGETHER
        moveAllTilesToStack();
        
        // GO THROUGH ALL OF THEM 
        for (ZombieCrushTile tile : stackTiles)
        {
            // AND SET THEM PROPERLY
            if (enable)
                tile.setState(VISIBLE_STATE);
            else
                tile.setState(INVISIBLE_STATE);
        }        
    }

    /**
     * This method examines the current game grid and finds and returns
     * a valid move that is available.
     * 
     * @return A move that can be made, or null if none exist.
     */
    public ZombieCrushMove findMove()
    {
        // MAKE A MOVE TO FILL IN 
        ZombieCrushMove move = new ZombieCrushMove();

        // GO THROUGH THE ENTIRE GRID TO FIND A MATCH BETWEEN AVAILABLE TILES
        for (int i = 0; i < gridColumns; i++)
        {
            for (int j = 0; j < gridRows; j++)
            {
                ArrayList<ZombieCrushTile> stack1 = tileGrid[i][j];
                if (stack1.size() > 0)
                {
                    // GET THE FIRST TILE
                    ZombieCrushTile testTile1 = stack1.get(stack1.size()-1);
                    for (int k = 0; k < gridColumns; k++)
                    {
                        for (int l = 0; l < gridRows; l++)
                        {
                            if (!((i == k) && (j == l)))
                            {      
                                ArrayList<ZombieCrushTile> stack2 = tileGrid[k][l];
                                if (stack2.size() > 0) 
                                {
                                    // AND TEST IT AGAINST THE SECOND TILE
                                    ZombieCrushTile testTile2 = stack2.get(stack2.size()-1);
                                    
                                    // DO THEY MATCH
                                    if (testTile1.match(testTile2)&&!testTile1.getState().equals(INCORRECTLY_SELECTED_STATE)&&!testTile2.getState().equals(INCORRECTLY_SELECTED_STATE))
                                    {
                                        // YES, FILL IN THE MOVE AND RETURN IT
                                        move.col1 = i;
                                        move.row1 = j;
                                        move.col2 = k;
                                        move.row2 = l;
                                        return move;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // WE'VE SEARCHED THE ENTIRE GRID AND THERE
        // ARE NO POSSIBLE MOVES REMAINING
        return null;
    }
     public ZombieCrushMove findThree(){
         ZombieCrushMove move = new ZombieCrushMove();
         return move;
    }
      public ZombieCrushMove findFour(){
         ZombieCrushMove move = new ZombieCrushMove();
         return move;
    }
       public ZombieCrushMove findFive(){
         ZombieCrushMove move = new ZombieCrushMove();
         //GO THROUGH THE WHOLE GRID AND SEE IF THERE'S 2 TILES TOGETHER. IF YES,SEE IF THERE ARE SAME TILES AROUND IN HORIZONAL/VERTI
         return move;
    }
    public ZombieCrushMove findT(){
         ZombieCrushMove move = new ZombieCrushMove();
         return move;
    }
     public ZombieCrushMove findL(){
         ZombieCrushMove move = new ZombieCrushMove();
         return move;
    }
     
    

    /**
     * This method moves all the tiles not currently in the stack 
     * to the stack.
     */
    public void moveAllTilesToStack()
    {
        for (int i = 0; i < gridColumns; i++)
        {
            for (int j = 0; j < gridRows; j++)
            {
                ArrayList<ZombieCrushTile> cellStack = tileGrid[i][j];
                moveTiles(cellStack, stackTiles);
            }
        }        
    }

    /**
     * This method removes all the tiles in from argument and moves them
     * to argument.
     * 
     * @param from The source data structure of tiles.
     * 
     * @param to The destination data structure of tiles.
     */
    private void moveTiles(ArrayList<ZombieCrushTile> from, ArrayList<ZombieCrushTile> to)
    {
        // GO THROUGH ALL THE TILES, TOP TO BOTTOM
        for (int i = from.size()-1; i >= 0; i--)
        {
            ZombieCrushTile tile = from.remove(i);
            
            // ONLY ADD IT IF IT'S NOT THERE ALREADY
            if (!to.contains(tile))
                to.add(tile);
        }        
    }
/**
     * This method updates all the necessary state information
     * to process the move argument.
     * 
     * @param move The move to make. Note that a move specifies
     * the cell locations for a match.
     */
    public void processMove(ZombieCrushMove move)
    {
        // REMOVE THE MOVE TILES FROM THE GRID
        ArrayList<ZombieCrushTile> stack1 = tileGrid[move.col1][move.row1];
        ArrayList<ZombieCrushTile> stack2 = tileGrid[move.col2][move.row2];        
        ZombieCrushTile tile1 = stack1.remove(stack1.size()-1);
        ZombieCrushTile tile2 = stack2.remove(stack2.size()-1);
        
        // MAKE SURE BOTH ARE UNSELECTED
        tile1.setState(VISIBLE_STATE);
        tile2.setState(VISIBLE_STATE);
        
        // SEND THEM TO THE STACK
        tile1.setTarget(TILE_STACK_X + TILE_STACK_OFFSET_X, TILE_STACK_Y + TILE_STACK_OFFSET_Y);
        tile1.startMovingToTarget(MAX_TILE_VELOCITY);
        tile2.setTarget(TILE_STACK_X + TILE_STACK_2_OFFSET_X, TILE_STACK_Y + TILE_STACK_OFFSET_Y);
        tile2.startMovingToTarget(MAX_TILE_VELOCITY);
        stackTiles.add(tile1);
        stackTiles.add(tile2);  
        
        // MAKE SURE THEY MOVE
        movingTiles.add(tile1);
        movingTiles.add(tile2);
       
        
 
        
        // NOW CHECK TO SEE IF THE GAME HAS EITHER BEEN WON OR LOST
        
        // HAS THE PLAYER WON?
        if (stackTiles.size() == NUM_TILES)
        {
            // YUP UPDATE EVERYTHING ACCORDINGLY
            endGameAsWin();
        }
        else
        {
            // SEE IF THERE ARE ANY MOVES LEFT
            ZombieCrushMove possibleMove = this.findMove();
            if (possibleMove == null)
            {
                // NOPE, WITH NO MOVES LEFT BUT TILES LEFT ON
                // THE GRID, THE PLAYER HAS LOST
                endGameAsLoss();
            }
        }
    }
    
    /**
     * This method attempts to select the selectTile argument. Note that
     * this may be the first or second selected tile. If a tile is already
     * selected, it will attempt to process a match/move.
     * 
     * @param selectTile The tile to select.
     */
    public void selectTile(ZombieCrushTile selectTile)
    {
    }
    public void calculateScore(){
        
    }
    
    @Override
    public void checkMousePressOnSprites(MiniGame mg, int i, int i1) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    
        /**
     * Called when a game is started, the game grid is reset.
     * 
     * @param game 
     */
    @Override
    public void reset(MiniGame game)
    {
        // PUT ALL THE TILES IN ONE PLACE AND MAKE THEM VISIBLE
        moveAllTilesToStack();
        for (ZombieCrushTile tile : stackTiles)
        {
            tile.setX(TILE_STACK_X);
            tile.setY(TILE_STACK_Y);
            tile.setState(VISIBLE_STATE);
        }        

        // RANDOMLY ORDER THEM
        Collections.shuffle(stackTiles);
        
        // START THE CLOCK
        startTime = new GregorianCalendar();
        
        // NOW LET'S REMOVE THEM FROM THE STACK
        // AND PUT THE TILES IN THE GRID        
        for (int i = 0; i < gridColumns; i++)
        {
            for (int j = 0; j < gridRows; j++)
            {
                for (int k = 0; k < levelGrid[i][j]; k++)
                {
                    // TAKE THE TILE OUT OF THE STACK
                    ZombieCrushTile tile = stackTiles.remove(stackTiles.size()-1);
                    
                    // PUT IT IN THE GRID
                    tileGrid[i][j].add(tile);
                    tile.setGridCell(i, j);
                    
                    // WE'LL ANIMATE IT GOING TO THE GRID, SO FIGURE
                    // OUT WHERE IT'S GOING AND GET IT MOVING
                    float x = calculateTileXInGrid(i, k);
                    float y = calculateTileYInGrid(j, k);
                    tile.setTarget(x, y);
                    tile.startMovingToTarget(MAX_TILE_VELOCITY);
                    movingTiles.add(tile);
                }
            }
        }        
        // AND START ALL UPDATES
        beginGame();
        
        // CLEAR ANY WIN OR LOSS DISPLAY
        miniGame.getGUIDialogs().get(WIN_DIALOG_TYPE).setState(INVISIBLE_STATE);
        miniGame.getGUIDialogs().get(STATS_DIALOG_TYPE).setState(INVISIBLE_STATE);
         miniGame.getGUIDialogs().get(LOSS_DIALOG_TYPE).setState(INVISIBLE_STATE);
    }    
    

    @Override
    public void updateAll(MiniGame game) {
       //updateAll(game,saga);
     
    }

    @Override
    public void updateDebugText(MiniGame mg) {
         //To change body of generated methods, choose Tools | Templates.
    }

}
